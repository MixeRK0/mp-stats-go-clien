/*
mpstats

MPStats API

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// WbApiService WbApi service
type WbApiService service

type ApiGetBrandByDateRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Бренд
func (r ApiGetBrandByDateRequest) Path(path string) ApiGetBrandByDateRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetBrandByDateRequest) D1(d1 string) ApiGetBrandByDateRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetBrandByDateRequest) D2(d2 string) ApiGetBrandByDateRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetBrandByDateRequest) Execute() ([]BrandByDate, *http.Response, error) {
	return r.ApiService.GetBrandByDateExecute(r)
}

/*
GetBrandByDate Данные по дням по бренду

Получение данных по дням по бренду

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrandByDateRequest
*/
func (a *WbApiService) GetBrandByDate(ctx context.Context) ApiGetBrandByDateRequest {
	return ApiGetBrandByDateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BrandByDate
func (a *WbApiService) GetBrandByDateExecute(r ApiGetBrandByDateRequest) ([]BrandByDate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BrandByDate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetBrandByDate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/brand/by_date"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandCategoriesRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Бренд
func (r ApiGetBrandCategoriesRequest) Path(path string) ApiGetBrandCategoriesRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetBrandCategoriesRequest) D1(d1 string) ApiGetBrandCategoriesRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetBrandCategoriesRequest) D2(d2 string) ApiGetBrandCategoriesRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetBrandCategoriesRequest) Execute() ([]BrandCategory, *http.Response, error) {
	return r.ApiService.GetBrandCategoriesExecute(r)
}

/*
GetBrandCategories Категории бренда

Получение данных о категориях бренда

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrandCategoriesRequest
*/
func (a *WbApiService) GetBrandCategories(ctx context.Context) ApiGetBrandCategoriesRequest {
	return ApiGetBrandCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BrandCategory
func (a *WbApiService) GetBrandCategoriesExecute(r ApiGetBrandCategoriesRequest) ([]BrandCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BrandCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetBrandCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/brand/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandDetailedItemsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
	getItemsRequestBody *GetItemsRequestBody
}

// Бренд
func (r ApiGetBrandDetailedItemsRequest) Path(path string) ApiGetBrandDetailedItemsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetBrandDetailedItemsRequest) D1(d1 string) ApiGetBrandDetailedItemsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetBrandDetailedItemsRequest) D2(d2 string) ApiGetBrandDetailedItemsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetBrandDetailedItemsRequest) GetItemsRequestBody(getItemsRequestBody GetItemsRequestBody) ApiGetBrandDetailedItemsRequest {
	r.getItemsRequestBody = &getItemsRequestBody
	return r
}

func (r ApiGetBrandDetailedItemsRequest) Execute() (*InlineResponse200, *http.Response, error) {
	return r.ApiService.GetBrandDetailedItemsExecute(r)
}

/*
GetBrandDetailedItems Товары бренда

Получение данных о товарах по бренду

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrandDetailedItemsRequest
*/
func (a *WbApiService) GetBrandDetailedItems(ctx context.Context) ApiGetBrandDetailedItemsRequest {
	return ApiGetBrandDetailedItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *WbApiService) GetBrandDetailedItemsExecute(r ApiGetBrandDetailedItemsRequest) (*InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetBrandDetailedItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/brand"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getItemsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandPriceSegmentationRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Бренд
func (r ApiGetBrandPriceSegmentationRequest) Path(path string) ApiGetBrandPriceSegmentationRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetBrandPriceSegmentationRequest) D1(d1 string) ApiGetBrandPriceSegmentationRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetBrandPriceSegmentationRequest) D2(d2 string) ApiGetBrandPriceSegmentationRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetBrandPriceSegmentationRequest) Execute() ([]BrandPriceSegmentation, *http.Response, error) {
	return r.ApiService.GetBrandPriceSegmentationExecute(r)
}

/*
GetBrandPriceSegmentation Ценовая сегментация бренда

Получение данных о ценовой сегментации бренда

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrandPriceSegmentationRequest
*/
func (a *WbApiService) GetBrandPriceSegmentation(ctx context.Context) ApiGetBrandPriceSegmentationRequest {
	return ApiGetBrandPriceSegmentationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BrandPriceSegmentation
func (a *WbApiService) GetBrandPriceSegmentationExecute(r ApiGetBrandPriceSegmentationRequest) ([]BrandPriceSegmentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BrandPriceSegmentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetBrandPriceSegmentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/brand/price_segmentation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandSellersRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Бренд
func (r ApiGetBrandSellersRequest) Path(path string) ApiGetBrandSellersRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetBrandSellersRequest) D1(d1 string) ApiGetBrandSellersRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetBrandSellersRequest) D2(d2 string) ApiGetBrandSellersRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetBrandSellersRequest) Execute() ([]BrandSeller, *http.Response, error) {
	return r.ApiService.GetBrandSellersExecute(r)
}

/*
GetBrandSellers Продавцы бренда

Получение данных о продавцах бренда

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrandSellersRequest
*/
func (a *WbApiService) GetBrandSellers(ctx context.Context) ApiGetBrandSellersRequest {
	return ApiGetBrandSellersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BrandSeller
func (a *WbApiService) GetBrandSellersExecute(r ApiGetBrandSellersRequest) ([]BrandSeller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BrandSeller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetBrandSellers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/brand/sellers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoriesRequest struct {
	ctx context.Context
	ApiService *WbApiService
}

func (r ApiGetCategoriesRequest) Execute() ([]CategoryPath, *http.Response, error) {
	return r.ApiService.GetCategoriesExecute(r)
}

/*
GetCategories Текущие категории

Получение текущих категорий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategoriesRequest
*/
func (a *WbApiService) GetCategories(ctx context.Context) ApiGetCategoriesRequest {
	return ApiGetCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategoryPath
func (a *WbApiService) GetCategoriesExecute(r ApiGetCategoriesRequest) ([]CategoryPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryBrandsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategoryBrandsRequest) Path(path string) ApiGetCategoryBrandsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategoryBrandsRequest) D1(d1 string) ApiGetCategoryBrandsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategoryBrandsRequest) D2(d2 string) ApiGetCategoryBrandsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategoryBrandsRequest) Execute() ([]CategoryBrand, *http.Response, error) {
	return r.ApiService.GetCategoryBrandsExecute(r)
}

/*
GetCategoryBrands Бренды категории

Получение данных о брендах категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategoryBrandsRequest
*/
func (a *WbApiService) GetCategoryBrands(ctx context.Context) ApiGetCategoryBrandsRequest {
	return ApiGetCategoryBrandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategoryBrand
func (a *WbApiService) GetCategoryBrandsExecute(r ApiGetCategoryBrandsRequest) ([]CategoryBrand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryBrand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategoryBrands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/brands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryByDateRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategoryByDateRequest) Path(path string) ApiGetCategoryByDateRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategoryByDateRequest) D1(d1 string) ApiGetCategoryByDateRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategoryByDateRequest) D2(d2 string) ApiGetCategoryByDateRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategoryByDateRequest) Execute() ([]CategoryByDate, *http.Response, error) {
	return r.ApiService.GetCategoryByDateExecute(r)
}

/*
GetCategoryByDate Данные по дням по категории

Получение данных по дням по категориии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategoryByDateRequest
*/
func (a *WbApiService) GetCategoryByDate(ctx context.Context) ApiGetCategoryByDateRequest {
	return ApiGetCategoryByDateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategoryByDate
func (a *WbApiService) GetCategoryByDateExecute(r ApiGetCategoryByDateRequest) ([]CategoryByDate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryByDate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategoryByDate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/by_date"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryItemsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
	getItemsRequestBody *GetItemsRequestBody
}

// Категория
func (r ApiGetCategoryItemsRequest) Path(path string) ApiGetCategoryItemsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategoryItemsRequest) D1(d1 string) ApiGetCategoryItemsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategoryItemsRequest) D2(d2 string) ApiGetCategoryItemsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategoryItemsRequest) GetItemsRequestBody(getItemsRequestBody GetItemsRequestBody) ApiGetCategoryItemsRequest {
	r.getItemsRequestBody = &getItemsRequestBody
	return r
}

func (r ApiGetCategoryItemsRequest) Execute() (*InlineResponse200, *http.Response, error) {
	return r.ApiService.GetCategoryItemsExecute(r)
}

/*
GetCategoryItems Товары категории

Получение данных о товарах категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategoryItemsRequest
*/
func (a *WbApiService) GetCategoryItems(ctx context.Context) ApiGetCategoryItemsRequest {
	return ApiGetCategoryItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *WbApiService) GetCategoryItemsExecute(r ApiGetCategoryItemsRequest) (*InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getItemsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryPriceSegmentationRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategoryPriceSegmentationRequest) Path(path string) ApiGetCategoryPriceSegmentationRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategoryPriceSegmentationRequest) D1(d1 string) ApiGetCategoryPriceSegmentationRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategoryPriceSegmentationRequest) D2(d2 string) ApiGetCategoryPriceSegmentationRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategoryPriceSegmentationRequest) Execute() ([]CategoryPriceSegmentation, *http.Response, error) {
	return r.ApiService.GetCategoryPriceSegmentationExecute(r)
}

/*
GetCategoryPriceSegmentation Ценовая сегментация категории

Получение данных о ценовой сегментации по категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategoryPriceSegmentationRequest
*/
func (a *WbApiService) GetCategoryPriceSegmentation(ctx context.Context) ApiGetCategoryPriceSegmentationRequest {
	return ApiGetCategoryPriceSegmentationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategoryPriceSegmentation
func (a *WbApiService) GetCategoryPriceSegmentationExecute(r ApiGetCategoryPriceSegmentationRequest) ([]CategoryPriceSegmentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryPriceSegmentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategoryPriceSegmentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/price_segmentation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategorySellersRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategorySellersRequest) Path(path string) ApiGetCategorySellersRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategorySellersRequest) D1(d1 string) ApiGetCategorySellersRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategorySellersRequest) D2(d2 string) ApiGetCategorySellersRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategorySellersRequest) Execute() ([]CategorySeller, *http.Response, error) {
	return r.ApiService.GetCategorySellersExecute(r)
}

/*
GetCategorySellers Продавцы категории

Получение данных о продавцах категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategorySellersRequest
*/
func (a *WbApiService) GetCategorySellers(ctx context.Context) ApiGetCategorySellersRequest {
	return ApiGetCategorySellersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategorySeller
func (a *WbApiService) GetCategorySellersExecute(r ApiGetCategorySellersRequest) ([]CategorySeller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategorySeller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategorySellers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/sellers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategorySubcategoriesRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategorySubcategoriesRequest) Path(path string) ApiGetCategorySubcategoriesRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategorySubcategoriesRequest) D1(d1 string) ApiGetCategorySubcategoriesRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategorySubcategoriesRequest) D2(d2 string) ApiGetCategorySubcategoriesRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategorySubcategoriesRequest) Execute() ([]CategorySubcategory, *http.Response, error) {
	return r.ApiService.GetCategorySubcategoriesExecute(r)
}

/*
GetCategorySubcategories Подкатегории категории

Получение данных по подкатегориям категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategorySubcategoriesRequest
*/
func (a *WbApiService) GetCategorySubcategories(ctx context.Context) ApiGetCategorySubcategoriesRequest {
	return ApiGetCategorySubcategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategorySubcategory
func (a *WbApiService) GetCategorySubcategoriesExecute(r ApiGetCategorySubcategoriesRequest) ([]CategorySubcategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategorySubcategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategorySubcategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/subcategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategorySubjectsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategorySubjectsRequest) Path(path string) ApiGetCategorySubjectsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategorySubjectsRequest) D1(d1 string) ApiGetCategorySubjectsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategorySubjectsRequest) D2(d2 string) ApiGetCategorySubjectsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategorySubjectsRequest) Execute() ([]CategorySubject, *http.Response, error) {
	return r.ApiService.GetCategorySubjectsExecute(r)
}

/*
GetCategorySubjects Предметы категории

Получение данных по предметам категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategorySubjectsRequest
*/
func (a *WbApiService) GetCategorySubjects(ctx context.Context) ApiGetCategorySubjectsRequest {
	return ApiGetCategorySubjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategorySubject
func (a *WbApiService) GetCategorySubjectsExecute(r ApiGetCategorySubjectsRequest) ([]CategorySubject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategorySubject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategorySubjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryTrendsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Категория
func (r ApiGetCategoryTrendsRequest) Path(path string) ApiGetCategoryTrendsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetCategoryTrendsRequest) D1(d1 string) ApiGetCategoryTrendsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetCategoryTrendsRequest) D2(d2 string) ApiGetCategoryTrendsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetCategoryTrendsRequest) Execute() ([]CategoryTrend, *http.Response, error) {
	return r.ApiService.GetCategoryTrendsExecute(r)
}

/*
GetCategoryTrends Тренды категории

Получение данных о трендах категории

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCategoryTrendsRequest
*/
func (a *WbApiService) GetCategoryTrends(ctx context.Context) ApiGetCategoryTrendsRequest {
	return ApiGetCategoryTrendsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CategoryTrend
func (a *WbApiService) GetCategoryTrendsExecute(r ApiGetCategoryTrendsRequest) ([]CategoryTrend, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryTrend
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetCategoryTrends")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/category/trends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemBalanceByDayRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
	d *string
}

// Дата
func (r ApiGetItemBalanceByDayRequest) D(d string) ApiGetItemBalanceByDayRequest {
	r.d = &d
	return r
}

func (r ApiGetItemBalanceByDayRequest) Execute() ([]ItemBalanceByDay, *http.Response, error) {
	return r.ApiService.GetItemBalanceByDayExecute(r)
}

/*
GetItemBalanceByDay Продажи и остатки товарной позиции за сутки

Получение продаж и остатков по товарной позиции за сутки

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemBalanceByDayRequest
*/
func (a *WbApiService) GetItemBalanceByDay(ctx context.Context, sku int32) ApiGetItemBalanceByDayRequest {
	return ApiGetItemBalanceByDayRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return []ItemBalanceByDay
func (a *WbApiService) GetItemBalanceByDayExecute(r ApiGetItemBalanceByDayRequest) ([]ItemBalanceByDay, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemBalanceByDay
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemBalanceByDay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}/balance_by_day"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.d != nil {
		localVarQueryParams.Add("d", parameterToString(*r.d, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemByCategoryRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
	d1 *string
	d2 *string
}

// Дата начала периода
func (r ApiGetItemByCategoryRequest) D1(d1 string) ApiGetItemByCategoryRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetItemByCategoryRequest) D2(d2 string) ApiGetItemByCategoryRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetItemByCategoryRequest) Execute() ([]ItemByCategory, *http.Response, error) {
	return r.ApiService.GetItemByCategoryExecute(r)
}

/*
GetItemByCategory История товарной позиции по категориям

Получение истории товарной позиции по категориям

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemByCategoryRequest
*/
func (a *WbApiService) GetItemByCategory(ctx context.Context, sku int32) ApiGetItemByCategoryRequest {
	return ApiGetItemByCategoryRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return []ItemByCategory
func (a *WbApiService) GetItemByCategoryExecute(r ApiGetItemByCategoryRequest) ([]ItemByCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemByCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemByCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}/by_category"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemBySkuRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
}

func (r ApiGetItemBySkuRequest) Execute() (*Item, *http.Response, error) {
	return r.ApiService.GetItemBySkuExecute(r)
}

/*
GetItemBySku Одна товарная позиция по SKU

Получение одной товарной позиции по SKU

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemBySkuRequest
*/
func (a *WbApiService) GetItemBySku(ctx context.Context, sku int32) ApiGetItemBySkuRequest {
	return ApiGetItemBySkuRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return Item
func (a *WbApiService) GetItemBySkuExecute(r ApiGetItemBySkuRequest) (*Item, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Item
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemBySku")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemOrdersByRegionRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
	d1 *string
	d2 *string
}

// Дата начала периода
func (r ApiGetItemOrdersByRegionRequest) D1(d1 string) ApiGetItemOrdersByRegionRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetItemOrdersByRegionRequest) D2(d2 string) ApiGetItemOrdersByRegionRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetItemOrdersByRegionRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetItemOrdersByRegionExecute(r)
}

/*
GetItemOrdersByRegion История заказов и остатков товарной позиции по складам

Получение истории заказов и остатков товарной позиции по складам

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemOrdersByRegionRequest
*/
func (a *WbApiService) GetItemOrdersByRegion(ctx context.Context, sku int32) ApiGetItemOrdersByRegionRequest {
	return ApiGetItemOrdersByRegionRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *WbApiService) GetItemOrdersByRegionExecute(r ApiGetItemOrdersByRegionRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemOrdersByRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}/orders_by_region"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemOrdersBySizeRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
	d1 *string
	d2 *string
}

// Дата начала периода
func (r ApiGetItemOrdersBySizeRequest) D1(d1 string) ApiGetItemOrdersBySizeRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetItemOrdersBySizeRequest) D2(d2 string) ApiGetItemOrdersBySizeRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetItemOrdersBySizeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetItemOrdersBySizeExecute(r)
}

/*
GetItemOrdersBySize История заказов и остатков товарной позиции по размерам

Получение истории заказов и остатков товарной позиции по размерам

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemOrdersBySizeRequest
*/
func (a *WbApiService) GetItemOrdersBySize(ctx context.Context, sku int32) ApiGetItemOrdersBySizeRequest {
	return ApiGetItemOrdersBySizeRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *WbApiService) GetItemOrdersBySizeExecute(r ApiGetItemOrdersBySizeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemOrdersBySize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}/orders_by_size"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemSalesRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
	d1 *string
	d2 *string
}

// Дата начала периода
func (r ApiGetItemSalesRequest) D1(d1 string) ApiGetItemSalesRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetItemSalesRequest) D2(d2 string) ApiGetItemSalesRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetItemSalesRequest) Execute() ([]ItemSale, *http.Response, error) {
	return r.ApiService.GetItemSalesExecute(r)
}

/*
GetItemSales Продажи и остатки товарной позиции

Получение продаж и остатков по товарной позиции

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemSalesRequest
*/
func (a *WbApiService) GetItemSales(ctx context.Context, sku int32) ApiGetItemSalesRequest {
	return ApiGetItemSalesRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return []ItemSale
func (a *WbApiService) GetItemSalesExecute(r ApiGetItemSalesRequest) ([]ItemSale, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemSale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemSales")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}/sales"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemSimilarRequest struct {
	ctx context.Context
	ApiService *WbApiService
	sku int32
	d1 *string
	d2 *string
}

// Дата начала периода
func (r ApiGetItemSimilarRequest) D1(d1 string) ApiGetItemSimilarRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetItemSimilarRequest) D2(d2 string) ApiGetItemSimilarRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetItemSimilarRequest) Execute() (*ItemSimilar, *http.Response, error) {
	return r.ApiService.GetItemSimilarExecute(r)
}

/*
GetItemSimilar Похожие товарные позиции

Получение похожих товарных позиций

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sku SKU
 @return ApiGetItemSimilarRequest
*/
func (a *WbApiService) GetItemSimilar(ctx context.Context, sku int32) ApiGetItemSimilarRequest {
	return ApiGetItemSimilarRequest{
		ApiService: a,
		ctx: ctx,
		sku: sku,
	}
}

// Execute executes the request
//  @return ItemSimilar
func (a *WbApiService) GetItemSimilarExecute(r ApiGetItemSimilarRequest) (*ItemSimilar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ItemSimilar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/item/{sku}/similar"
	localVarPath = strings.Replace(localVarPath, "{"+"sku"+"}", url.PathEscape(parameterToString(r.sku, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsBatchRequest struct {
	ctx context.Context
	ApiService *WbApiService
	getItemsBatchRequestBody *GetItemsBatchRequestBody
}

func (r ApiGetItemsBatchRequest) GetItemsBatchRequestBody(getItemsBatchRequestBody GetItemsBatchRequestBody) ApiGetItemsBatchRequest {
	r.getItemsBatchRequestBody = &getItemsBatchRequestBody
	return r
}

func (r ApiGetItemsBatchRequest) Execute() ([]Item, *http.Response, error) {
	return r.ApiService.GetItemsBatchExecute(r)
}

/*
GetItemsBatch Товарные позиции по SKU

Получение товарных позиций по SKU

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemsBatchRequest
*/
func (a *WbApiService) GetItemsBatch(ctx context.Context) ApiGetItemsBatchRequest {
	return ApiGetItemsBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Item
func (a *WbApiService) GetItemsBatchExecute(r ApiGetItemsBatchRequest) ([]Item, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Item
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetItemsBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/items/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getItemsBatchRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellerBrandsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Продавец
func (r ApiGetSellerBrandsRequest) Path(path string) ApiGetSellerBrandsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSellerBrandsRequest) D1(d1 string) ApiGetSellerBrandsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSellerBrandsRequest) D2(d2 string) ApiGetSellerBrandsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSellerBrandsRequest) Execute() ([]SellerBrand, *http.Response, error) {
	return r.ApiService.GetSellerBrandsExecute(r)
}

/*
GetSellerBrands Бренды продавца

Получение данных по брендам по продавцу

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSellerBrandsRequest
*/
func (a *WbApiService) GetSellerBrands(ctx context.Context) ApiGetSellerBrandsRequest {
	return ApiGetSellerBrandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SellerBrand
func (a *WbApiService) GetSellerBrandsExecute(r ApiGetSellerBrandsRequest) ([]SellerBrand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SellerBrand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSellerBrands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/seller/brands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellerByDateRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Продавец
func (r ApiGetSellerByDateRequest) Path(path string) ApiGetSellerByDateRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSellerByDateRequest) D1(d1 string) ApiGetSellerByDateRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSellerByDateRequest) D2(d2 string) ApiGetSellerByDateRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSellerByDateRequest) Execute() ([]SellerByDate, *http.Response, error) {
	return r.ApiService.GetSellerByDateExecute(r)
}

/*
GetSellerByDate Данные по дням по продавцу

Получение данных по дням по продавцу

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSellerByDateRequest
*/
func (a *WbApiService) GetSellerByDate(ctx context.Context) ApiGetSellerByDateRequest {
	return ApiGetSellerByDateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SellerByDate
func (a *WbApiService) GetSellerByDateExecute(r ApiGetSellerByDateRequest) ([]SellerByDate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SellerByDate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSellerByDate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/seller/by_date"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellerCategoriesRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Продавец
func (r ApiGetSellerCategoriesRequest) Path(path string) ApiGetSellerCategoriesRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSellerCategoriesRequest) D1(d1 string) ApiGetSellerCategoriesRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSellerCategoriesRequest) D2(d2 string) ApiGetSellerCategoriesRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSellerCategoriesRequest) Execute() ([]SellerCategory, *http.Response, error) {
	return r.ApiService.GetSellerCategoriesExecute(r)
}

/*
GetSellerCategories Категории продавца

Получение данных по категориям по продавцу

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSellerCategoriesRequest
*/
func (a *WbApiService) GetSellerCategories(ctx context.Context) ApiGetSellerCategoriesRequest {
	return ApiGetSellerCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SellerCategory
func (a *WbApiService) GetSellerCategoriesExecute(r ApiGetSellerCategoriesRequest) ([]SellerCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SellerCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSellerCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/seller/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellerDetailedItemsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	supplierId *int32
	d1 *string
	d2 *string
	getItemsRequestBody *GetItemsRequestBody
}

// Продавец
func (r ApiGetSellerDetailedItemsRequest) Path(path string) ApiGetSellerDetailedItemsRequest {
	r.path = &path
	return r
}

// Идентификатор продавца
func (r ApiGetSellerDetailedItemsRequest) SupplierId(supplierId int32) ApiGetSellerDetailedItemsRequest {
	r.supplierId = &supplierId
	return r
}

// Дата начала периода
func (r ApiGetSellerDetailedItemsRequest) D1(d1 string) ApiGetSellerDetailedItemsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSellerDetailedItemsRequest) D2(d2 string) ApiGetSellerDetailedItemsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSellerDetailedItemsRequest) GetItemsRequestBody(getItemsRequestBody GetItemsRequestBody) ApiGetSellerDetailedItemsRequest {
	r.getItemsRequestBody = &getItemsRequestBody
	return r
}

func (r ApiGetSellerDetailedItemsRequest) Execute() (*InlineResponse200, *http.Response, error) {
	return r.ApiService.GetSellerDetailedItemsExecute(r)
}

/*
GetSellerDetailedItems Товары продавца

Получение данных о товарах по продавцу

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSellerDetailedItemsRequest
*/
func (a *WbApiService) GetSellerDetailedItems(ctx context.Context) ApiGetSellerDetailedItemsRequest {
	return ApiGetSellerDetailedItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *WbApiService) GetSellerDetailedItemsExecute(r ApiGetSellerDetailedItemsRequest) (*InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSellerDetailedItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/seller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.supplierId == nil {
		return localVarReturnValue, nil, reportError("supplierId is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	localVarQueryParams.Add("supplierId", parameterToString(*r.supplierId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getItemsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSellerPriceSegmentationRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// Продавец
func (r ApiGetSellerPriceSegmentationRequest) Path(path string) ApiGetSellerPriceSegmentationRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSellerPriceSegmentationRequest) D1(d1 string) ApiGetSellerPriceSegmentationRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSellerPriceSegmentationRequest) D2(d2 string) ApiGetSellerPriceSegmentationRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSellerPriceSegmentationRequest) Execute() ([]SellerPriceSegmentation, *http.Response, error) {
	return r.ApiService.GetSellerPriceSegmentationExecute(r)
}

/*
GetSellerPriceSegmentation Ценовая сегментация продавца

Получение данных о ценовой сегментации продавца

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSellerPriceSegmentationRequest
*/
func (a *WbApiService) GetSellerPriceSegmentation(ctx context.Context) ApiGetSellerPriceSegmentationRequest {
	return ApiGetSellerPriceSegmentationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SellerPriceSegmentation
func (a *WbApiService) GetSellerPriceSegmentationExecute(r ApiGetSellerPriceSegmentationRequest) ([]SellerPriceSegmentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SellerPriceSegmentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSellerPriceSegmentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/seller/price_segmentation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimilarBrandsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// SKU
func (r ApiGetSimilarBrandsRequest) Path(path string) ApiGetSimilarBrandsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSimilarBrandsRequest) D1(d1 string) ApiGetSimilarBrandsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSimilarBrandsRequest) D2(d2 string) ApiGetSimilarBrandsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSimilarBrandsRequest) Execute() ([]SimilarBrand, *http.Response, error) {
	return r.ApiService.GetSimilarBrandsExecute(r)
}

/*
GetSimilarBrands Бренды похожего товара

Получение данных по брендам похожего товара

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimilarBrandsRequest
*/
func (a *WbApiService) GetSimilarBrands(ctx context.Context) ApiGetSimilarBrandsRequest {
	return ApiGetSimilarBrandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SimilarBrand
func (a *WbApiService) GetSimilarBrandsExecute(r ApiGetSimilarBrandsRequest) ([]SimilarBrand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SimilarBrand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSimilarBrands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/similar/brands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimilarByDateRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// SKU
func (r ApiGetSimilarByDateRequest) Path(path string) ApiGetSimilarByDateRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSimilarByDateRequest) D1(d1 string) ApiGetSimilarByDateRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSimilarByDateRequest) D2(d2 string) ApiGetSimilarByDateRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSimilarByDateRequest) Execute() ([]SimilarByDate, *http.Response, error) {
	return r.ApiService.GetSimilarByDateExecute(r)
}

/*
GetSimilarByDate По дням

Получение данных по дням по похожему товару

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimilarByDateRequest
*/
func (a *WbApiService) GetSimilarByDate(ctx context.Context) ApiGetSimilarByDateRequest {
	return ApiGetSimilarByDateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SimilarByDate
func (a *WbApiService) GetSimilarByDateExecute(r ApiGetSimilarByDateRequest) ([]SimilarByDate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SimilarByDate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSimilarByDate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/similar/by_date"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimilarCategoriesRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// SKU
func (r ApiGetSimilarCategoriesRequest) Path(path string) ApiGetSimilarCategoriesRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSimilarCategoriesRequest) D1(d1 string) ApiGetSimilarCategoriesRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSimilarCategoriesRequest) D2(d2 string) ApiGetSimilarCategoriesRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSimilarCategoriesRequest) Execute() ([]SimilarCategory, *http.Response, error) {
	return r.ApiService.GetSimilarCategoriesExecute(r)
}

/*
GetSimilarCategories Категории похожего товара

Получение данных по категориям по похожему товару

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimilarCategoriesRequest
*/
func (a *WbApiService) GetSimilarCategories(ctx context.Context) ApiGetSimilarCategoriesRequest {
	return ApiGetSimilarCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SimilarCategory
func (a *WbApiService) GetSimilarCategoriesExecute(r ApiGetSimilarCategoriesRequest) ([]SimilarCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SimilarCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSimilarCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/similar/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimilarDetailedItemsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
	getItemsRequestBody *GetItemsRequestBody
}

// SKU
func (r ApiGetSimilarDetailedItemsRequest) Path(path string) ApiGetSimilarDetailedItemsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSimilarDetailedItemsRequest) D1(d1 string) ApiGetSimilarDetailedItemsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSimilarDetailedItemsRequest) D2(d2 string) ApiGetSimilarDetailedItemsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSimilarDetailedItemsRequest) GetItemsRequestBody(getItemsRequestBody GetItemsRequestBody) ApiGetSimilarDetailedItemsRequest {
	r.getItemsRequestBody = &getItemsRequestBody
	return r
}

func (r ApiGetSimilarDetailedItemsRequest) Execute() (*InlineResponse200, *http.Response, error) {
	return r.ApiService.GetSimilarDetailedItemsExecute(r)
}

/*
GetSimilarDetailedItems Товары по похожему товару

Получение данных о товарах по похожему товару

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimilarDetailedItemsRequest
*/
func (a *WbApiService) GetSimilarDetailedItems(ctx context.Context) ApiGetSimilarDetailedItemsRequest {
	return ApiGetSimilarDetailedItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *WbApiService) GetSimilarDetailedItemsExecute(r ApiGetSimilarDetailedItemsRequest) (*InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSimilarDetailedItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/similar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getItemsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimilarSellersRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
}

// SKU
func (r ApiGetSimilarSellersRequest) Path(path string) ApiGetSimilarSellersRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSimilarSellersRequest) D1(d1 string) ApiGetSimilarSellersRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSimilarSellersRequest) D2(d2 string) ApiGetSimilarSellersRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSimilarSellersRequest) Execute() ([]SimilarSeller, *http.Response, error) {
	return r.ApiService.GetSimilarSellersExecute(r)
}

/*
GetSimilarSellers Продавцы похожего товара

Получение данных по продавцам похожего товара

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimilarSellersRequest
*/
func (a *WbApiService) GetSimilarSellers(ctx context.Context) ApiGetSimilarSellersRequest {
	return ApiGetSimilarSellersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SimilarSeller
func (a *WbApiService) GetSimilarSellersExecute(r ApiGetSimilarSellersRequest) ([]SimilarSeller, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SimilarSeller
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSimilarSellers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/similar/sellers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubjectItemsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
	getItemsRequestBody *GetItemsRequestBody
}

// Категория
func (r ApiGetSubjectItemsRequest) Path(path string) ApiGetSubjectItemsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiGetSubjectItemsRequest) D1(d1 string) ApiGetSubjectItemsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiGetSubjectItemsRequest) D2(d2 string) ApiGetSubjectItemsRequest {
	r.d2 = &d2
	return r
}

func (r ApiGetSubjectItemsRequest) GetItemsRequestBody(getItemsRequestBody GetItemsRequestBody) ApiGetSubjectItemsRequest {
	r.getItemsRequestBody = &getItemsRequestBody
	return r
}

func (r ApiGetSubjectItemsRequest) Execute() (*InlineResponse200, *http.Response, error) {
	return r.ApiService.GetSubjectItemsExecute(r)
}

/*
GetSubjectItems Получить список товаров по предмету

Получение списка товаров по предмету

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubjectItemsRequest
*/
func (a *WbApiService) GetSubjectItems(ctx context.Context) ApiGetSubjectItemsRequest {
	return ApiGetSubjectItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *WbApiService) GetSubjectItemsExecute(r ApiGetSubjectItemsRequest) (*InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.GetSubjectItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/subject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getItemsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostWbGetSearchCategoriesRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
	tplsRequestBody *TplsRequestBody
}

// Поисковой запрос
func (r ApiPostWbGetSearchCategoriesRequest) Path(path string) ApiPostWbGetSearchCategoriesRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiPostWbGetSearchCategoriesRequest) D1(d1 string) ApiPostWbGetSearchCategoriesRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiPostWbGetSearchCategoriesRequest) D2(d2 string) ApiPostWbGetSearchCategoriesRequest {
	r.d2 = &d2
	return r
}

func (r ApiPostWbGetSearchCategoriesRequest) TplsRequestBody(tplsRequestBody TplsRequestBody) ApiPostWbGetSearchCategoriesRequest {
	r.tplsRequestBody = &tplsRequestBody
	return r
}

func (r ApiPostWbGetSearchCategoriesRequest) Execute() ([]SearchCategoriesElement, *http.Response, error) {
	return r.ApiService.PostWbGetSearchCategoriesExecute(r)
}

/*
PostWbGetSearchCategories GetSearchCategories

Search categories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostWbGetSearchCategoriesRequest
*/
func (a *WbApiService) PostWbGetSearchCategories(ctx context.Context) ApiPostWbGetSearchCategoriesRequest {
	return ApiPostWbGetSearchCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SearchCategoriesElement
func (a *WbApiService) PostWbGetSearchCategoriesExecute(r ApiPostWbGetSearchCategoriesRequest) ([]SearchCategoriesElement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SearchCategoriesElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.PostWbGetSearchCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/search/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tplsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostWbGetSearchItemsRequest struct {
	ctx context.Context
	ApiService *WbApiService
	path *string
	d1 *string
	d2 *string
	getSearchItemsRequestBody *GetSearchItemsRequestBody
}

// Поисковой запрос
func (r ApiPostWbGetSearchItemsRequest) Path(path string) ApiPostWbGetSearchItemsRequest {
	r.path = &path
	return r
}

// Дата начала периода
func (r ApiPostWbGetSearchItemsRequest) D1(d1 string) ApiPostWbGetSearchItemsRequest {
	r.d1 = &d1
	return r
}

// Дата окончания периода
func (r ApiPostWbGetSearchItemsRequest) D2(d2 string) ApiPostWbGetSearchItemsRequest {
	r.d2 = &d2
	return r
}

func (r ApiPostWbGetSearchItemsRequest) GetSearchItemsRequestBody(getSearchItemsRequestBody GetSearchItemsRequestBody) ApiPostWbGetSearchItemsRequest {
	r.getSearchItemsRequestBody = &getSearchItemsRequestBody
	return r
}

func (r ApiPostWbGetSearchItemsRequest) Execute() (*SearchItems, *http.Response, error) {
	return r.ApiService.PostWbGetSearchItemsExecute(r)
}

/*
PostWbGetSearchItems GetSearchItems

Search items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostWbGetSearchItemsRequest
*/
func (a *WbApiService) PostWbGetSearchItems(ctx context.Context) ApiPostWbGetSearchItemsRequest {
	return ApiPostWbGetSearchItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchItems
func (a *WbApiService) PostWbGetSearchItemsExecute(r ApiPostWbGetSearchItemsRequest) (*SearchItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WbApiService.PostWbGetSearchItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wb/get/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	if r.d1 != nil {
		localVarQueryParams.Add("d1", parameterToString(*r.d1, ""))
	}
	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	if r.d2 != nil {
		localVarQueryParams.Add("d2", parameterToString(*r.d2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSearchItemsRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Header-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Mpstats-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
